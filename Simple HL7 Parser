{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [],
   "source": [
    "import re\n",
    "import os\n",
    "import sys\n",
    "import warnings\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "\n",
    "\n",
    "delims= [\n",
    "    \n",
    "    ('\\&',    'AND'),\n",
    "    ('\\~',    'TILDE'),\n",
    "    (r'\\\\',   'BACK_SLASH'),\n",
    "    ('\\^',    'HAT'),\n",
    "    ('\\#',   'TAG')\n",
    "\n",
    "]\n",
    "\n",
    "\n",
    "regex_parts=[]\n",
    "group={}\n",
    "for regex, types in delims:\n",
    "    regex_parts.append('(?P<%s>%s)' % (types, regex))\n",
    "regex=re.compile('|'.join(regex_parts))\n",
    "\n",
    "\n",
    "def parser (message):\n",
    "    message_array= np.array ([['smack']], dtype='<U200')\n",
    "    parser=re.compile ('\\|')\n",
    "    position_parser=parser.search(message)\n",
    "    if not position_parser: \n",
    "        message_array[0]=message\n",
    "        return message_array\n",
    "    else:\n",
    "        position_parser=parser.search(message).end()-1\n",
    "        index=message [: (position_parser)]\n",
    "        message_array [0]=index\n",
    "        message=message[(position_parser+1) :]\n",
    "        position_parser=0\n",
    "        i=0\n",
    "        while 1:\n",
    "            k=parser.search(message)\n",
    "            if k:\n",
    "                m=k.end()-1\n",
    "                if m==position_parser:\n",
    "                    message_array=np.append (message_array, np.array([['Empty']]), 1)\n",
    "                    message=message[(position_parser+1) :]\n",
    "                else:\n",
    "                    block=message[: m]\n",
    "                    message_array=np.append (message_array, np.array([[block]]), 1)\n",
    "                    message=message[(m+1) :]\n",
    "            else: \n",
    "                message_array=np.append(message_array, np.array([message]))\n",
    "                break\n",
    "    \n",
    "        return message_array\n",
    "\n",
    "def parser_p (message):\n",
    "    message_array=parser(message)\n",
    "    block={}\n",
    "    cc=[]\n",
    "    mesa=np.reshape (message_array, (len(message_array), ))\n",
    "    for i in range (len(mesa)):\n",
    "        block_i=np.array(['Null'], dtype=\"<U200\")\n",
    "        count=0\n",
    "        while 1:\n",
    "            k=regex.search(mesa[i])\n",
    "            if k:\n",
    "                if not i in cc:\n",
    "                    cc.append(i)\n",
    "                m=k.end()-1\n",
    "                if m !=0:\n",
    "                    block_i=np.append (block_i, np.array([mesa[i][:(m)]]))\n",
    "                    mesa[i]=mesa[i][(m+1):]\n",
    "                else:\n",
    "                    mesa[i]=mesa[i][(m+1):]\n",
    "                count+=1\n",
    "                block[i]=block_i[1:]\n",
    "            else:\n",
    "                if count!= 0 and len(mesa[i])!=0:\n",
    "                    block_i=np.append(block_i, [mesa[i]])\n",
    "                    block[i]=block_i[1:]\n",
    "                break\n",
    "            \n",
    "    return block, cc\n",
    "\n",
    "def listing (message):\n",
    "    parsed=parser(message)\n",
    "    parsed_p=parser_p(message)\n",
    "    t=[]\n",
    "    check=0\n",
    "    for i in parsed:\n",
    "        if check in parsed_p[1]:\n",
    "            lst=parsed_p[0][check]\n",
    "            np.reshape(lst, (len(lst)))\n",
    "            lst=lst.tolist()\n",
    "            t.append(lst)\n",
    "        else:\n",
    "            t.append([i])\n",
    "        check+=1\n",
    "    return t\n",
    "\n",
    "\n",
    "def hl7 (path, file=True):\n",
    "    if file:\n",
    "        file=open(path, 'r')\n",
    "        lines=file.readlines()\n",
    "        total={}\n",
    "        i=1\n",
    "        for line in lines:\n",
    "            t=listing(line)\n",
    "            if t[0]==['MSH']:\n",
    "                t[1]=['^~\\\\&']\n",
    "            total['%s' % t[0][0]]=t[1:]\n",
    "    else:\n",
    "        t=listing(path)\n",
    "        if t[0]==['MSH']:\n",
    "            t[1]=['^~\\\\&']\n",
    "        total['%s' % t[0]]=t[1:]\n",
    "    return total"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
